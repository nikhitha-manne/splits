rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection rules (private - self-only)
    match /users/{userId} {
      // Allow read if authenticated and reading own document
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Allow create only if:
      // 1. User is authenticated
      // 2. userId matches authenticated user's uid
      // 3. Required fields are present
      // 4. Role is set to 'member' (admins cannot be created during signup)
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasAll(['uid', 'name', 'email', 'defaultCurrency', 'role', 'createdAt'])
        && request.resource.data.uid == userId
        && request.resource.data.role == 'member'
        && request.resource.data.email is string
        && request.resource.data.name is string
        && request.resource.data.defaultCurrency is string;
      
      // Allow update if:
      // 1. User is authenticated
      // 2. userId matches authenticated user's uid
      // 3. Role cannot be changed (only admins can change roles, handled server-side later)
      allow update: if request.auth != null
        && request.auth.uid == userId
        && (!request.resource.data.diff(request.resource.data).affectedKeys().hasAny(['role', 'uid']));
      
      // Deny delete (users cannot delete their own documents directly)
      allow delete: if false;

      // Group refs subcollection - user can read/write their own group refs
      match /groupRefs/{groupId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Public users collection rules (display-only, readable by all authenticated users)
    match /publicUsers/{userId} {
      // Allow read by any authenticated user (for displaying names/avatars)
      allow read: if request.auth != null;
      
      // Allow create/update only by the user themselves (when creating/updating profile)
      allow create, update: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.uid == userId;
      
      // Deny delete (public user profiles cannot be deleted)
      allow delete: if false;
    }
    
    // Groups collection rules
    match /groups/{groupId} {
      // Helper function to check if user is a member of the group
      function isMember() {
        return request.auth != null
          && exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid));
      }

      // Helper function to check if user is an admin of the group
      function isAdmin() {
        return request.auth != null
          && isMember()
          && get(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin';
      }

      // Allow read if user is a member of the group
      allow read: if isMember();

      // Allow create if authenticated (anyone can create a group)
      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['name', 'createdBy', 'createdAt', 'updatedAt'])
        && request.resource.data.createdBy == request.auth.uid;

      // Allow update if user is an admin of the group
      allow update: if isAdmin();

      // Deny delete (groups cannot be deleted)
      allow delete: if false;

      // Members subcollection rules
      match /members/{memberId} {
        // Allow read if user is a member of the group
        allow read: if isMember();

        // Allow create if user is an admin (adding members) OR if creating own membership (when accepting invite)
        allow create: if request.auth != null
          && (
            isAdmin()
            || (request.auth.uid == memberId && request.resource.data.userId == request.auth.uid)
          );

        // Allow update if user is an admin (changing roles) OR if updating own membership
        allow update: if request.auth != null
          && (
            isAdmin()
            || (request.auth.uid == memberId)
          );

        // Allow delete if user is an admin (removing members)
        allow delete: if isAdmin();
      }
    }

    // Invites collection rules
    match /invites/{inviteId} {
      // Helper function to check if user is admin of the group (for the invite's group)
      function isGroupAdmin(groupId) {
        return request.auth != null
          && exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid))
          && get(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin';
      }

      // Allow read if:
      // 1. User created the invite
      // 2. User is an admin of the group
      // Note: Link invites are accessed via token query, so users can query with token to find invites
      allow read: if request.auth != null && (
        resource.data.createdBy == request.auth.uid
        || isGroupAdmin(resource.data.groupId)
      );

      // Allow create if user is an admin of the group
      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['groupId', 'createdBy', 'type', 'token', 'status', 'createdAt'])
        && request.resource.data.createdBy == request.auth.uid
        && isGroupAdmin(request.resource.data.groupId);

      // Allow update if:
      // 1. User is accepting the invite (updating status to accepted)
      // 2. Creator is updating the invite (e.g., revoking)
      // 3. Group admin is updating the invite
      // Note: Cloud Functions run with admin privileges and bypass these rules
      allow update: if request.auth != null
        && (
          (request.resource.data.status == 'accepted' && request.resource.data.acceptedBy == request.auth.uid)
          || resource.data.createdBy == request.auth.uid
          || isGroupAdmin(resource.data.groupId)
        );

      // Deny delete
      allow delete: if false;
    }

    // Direct threads collection rules
    match /directThreads/{threadId} {
      // Helper function to check if user is a member of the thread
      function isMember() {
        return request.auth != null
          && request.auth.uid in resource.data.memberIds;
      }

      // Allow read if user is a member
      allow read: if isMember();

      // Allow create if:
      // 1. User is authenticated
      // 2. User is in memberIds
      // 3. memberIds has exactly length 2
      // 4. memberIds contains request.auth.uid
      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['memberIds', 'createdBy', 'createdAt', 'lastActivityAt'])
        && request.auth.uid in request.resource.data.memberIds
        && request.resource.data.memberIds.size() == 2
        && request.resource.data.createdBy == request.auth.uid;

      // Allow update if user is a member (for lastActivityAt updates)
      allow update: if isMember();

      // Deny delete
      allow delete: if false;
    }

    // Expenses collection rules
    match /expenses/{expenseId} {
      // Helper function to check if expense is for a group and user is a member
      function isGroupMember() {
        return request.auth != null
          && resource.data.containerType == 'group'
          && resource.data.groupId != null
          && exists(/databases/$(database)/documents/groups/$(resource.data.groupId)/members/$(request.auth.uid));
      }

      // Helper function to check if expense is for a direct thread and user is a member
      function isDirectMember() {
        return request.auth != null
          && resource.data.containerType == 'direct'
          && resource.data.directId != null
          && exists(/databases/$(database)/documents/directThreads/$(resource.data.directId))
          && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(resource.data.directId)).data.memberIds;
      }

      // Helper function for subcollections to check parent expense access
      function canAccessExpense() {
        let expenseData = get(/databases/$(database)/documents/expenses/$(expenseId)).data;
        return request.auth != null
          && (
            (expenseData.containerType == 'group'
              && expenseData.groupId != null
              && exists(/databases/$(database)/documents/groups/$(expenseData.groupId)/members/$(request.auth.uid)))
            || (expenseData.containerType == 'direct'
              && expenseData.directId != null
              && exists(/databases/$(database)/documents/directThreads/$(expenseData.directId))
              && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(expenseData.directId)).data.memberIds)
          );
      }

      // Allow read if user is a member (group or direct)
      allow read: if request.auth != null && (isGroupMember() || isDirectMember());

      // Allow create if:
      // 1. User is authenticated
      // 2. User is a member of the container (group or direct)
      // 3. containerType matches and corresponding ID is set
      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['containerType', 'title', 'currency', 'totalAmount', 'splitType', 'participantIds', 'createdBy', 'createdAt', 'updatedAt', 'editedFlag'])
        && (
          (request.resource.data.containerType == 'group'
            && request.resource.data.groupId != null
            && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid)))
          || (request.resource.data.containerType == 'direct'
            && request.resource.data.directId != null
            && exists(/databases/$(database)/documents/directThreads/$(request.resource.data.directId))
            && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(request.resource.data.directId)).data.memberIds)
        )
        && request.resource.data.createdBy == request.auth.uid;

      // Allow update if user is a member (for editing expenses)
      allow update: if request.auth != null && (isGroupMember() || isDirectMember());

      // Deny delete (expenses cannot be deleted)
      allow delete: if false;

      // Payers subcollection rules
      match /payers/{payerId} {
        // Allow read if user can access the parent expense
        allow read: if canAccessExpense();

        // Allow create/update if user can access the parent expense
        allow create, update: if canAccessExpense();

        // Deny delete
        allow delete: if false;
      }

      // Splits subcollection rules
      match /splits/{splitId} {
        // Allow read if user can access the parent expense
        allow read: if canAccessExpense();

        // Allow create/update if user can access the parent expense
        allow create, update: if canAccessExpense();

        // Deny delete
        allow delete: if false;
      }
    }

    // Settlements collection rules
    match /settlements/{settlementId} {
      // Helper function to check if settlement is for a group and user is a member
      function isGroupMember() {
        return request.auth != null
          && resource.data.containerType == 'group'
          && resource.data.groupId != null
          && exists(/databases/$(database)/documents/groups/$(resource.data.groupId)/members/$(request.auth.uid));
      }

      // Helper function to check if settlement is for a direct thread and user is a member
      function isDirectMember() {
        return request.auth != null
          && resource.data.containerType == 'direct'
          && resource.data.directId != null
          && exists(/databases/$(database)/documents/directThreads/$(resource.data.directId))
          && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(resource.data.directId)).data.memberIds;
      }

      // Helper function to check if user is admin of the group (for reversal authorization)
      function isGroupAdmin() {
        return request.auth != null
          && resource.data.containerType == 'group'
          && resource.data.groupId != null
          && exists(/databases/$(database)/documents/groups/$(resource.data.groupId)/members/$(request.auth.uid))
          && get(/databases/$(database)/documents/groups/$(resource.data.groupId)/members/$(request.auth.uid)).data.role == 'admin';
      }

      // Allow read if user is a member (group or direct)
      allow read: if request.auth != null && (isGroupMember() || isDirectMember());

      // Allow create if:
      // 1. User is authenticated
      // 2. User is a member of the container (group or direct)
      // 3. containerType matches and corresponding ID is set
      // 4. fromUserId and toUserId are members
      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['containerType', 'fromUserId', 'toUserId', 'amount', 'currency', 'normalizedFromAmount', 'normalizedToAmount', 'conversionRateFrom', 'conversionRateTo', 'createdAt', 'createdBy', 'status'])
        && request.resource.data.status == 'COMPLETED'
        && (
          (request.resource.data.containerType == 'group'
            && request.resource.data.groupId != null
            && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid))
            && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.resource.data.fromUserId))
            && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.resource.data.toUserId)))
          || (request.resource.data.containerType == 'direct'
            && request.resource.data.directId != null
            && exists(/databases/$(database)/documents/directThreads/$(request.resource.data.directId))
            && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(request.resource.data.directId)).data.memberIds
            && request.resource.data.fromUserId in get(/databases/$(database)/documents/directThreads/$(request.resource.data.directId)).data.memberIds
            && request.resource.data.toUserId in get(/databases/$(database)/documents/directThreads/$(request.resource.data.directId)).data.memberIds)
        )
        && request.resource.data.createdBy == request.auth.uid;

      // Allow update only for reversal:
      // 1. Must be updating status to REVERSED
      // 2. Only creator OR group admin (if group) OR either member (if direct) can reverse
      // 3. Current status must be COMPLETED
      allow update: if request.auth != null
        && resource.data.status == 'COMPLETED'
        && request.resource.data.status == 'REVERSED'
        && request.resource.data.keys().hasAll(['reversedAt', 'reversedBy'])
        && request.resource.data.reversedBy == request.auth.uid
        && (
          resource.data.createdBy == request.auth.uid
          || isGroupAdmin()
          || (resource.data.containerType == 'direct' && isDirectMember())
        );

      // Deny delete (settlements cannot be deleted)
      allow delete: if false;
    }

    // Bill uploads collection rules
    match /billUploads/{billUploadId} {
      // Helper function to check if bill upload is for a group and user is a member
      function isGroupMember() {
        return request.auth != null
          && resource.data.containerType == 'group'
          && resource.data.groupId != null
          && exists(/databases/$(database)/documents/groups/$(resource.data.groupId)/members/$(request.auth.uid));
      }

      // Helper function to check if bill upload is for a direct thread and user is a member
      function isDirectMember() {
        return request.auth != null
          && resource.data.containerType == 'direct'
          && resource.data.directId != null
          && exists(/databases/$(database)/documents/directThreads/$(resource.data.directId))
          && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(resource.data.directId)).data.memberIds;
      }

      // Helper function for subcollections to check parent bill upload access
      function canAccessBillUpload() {
        let billData = get(/databases/$(database)/documents/billUploads/$(billUploadId)).data;
        return request.auth != null
          && (
            (billData.containerType == 'group'
              && billData.groupId != null
              && exists(/databases/$(database)/documents/groups/$(billData.groupId)/members/$(request.auth.uid)))
            || (billData.containerType == 'direct'
              && billData.directId != null
              && exists(/databases/$(database)/documents/directThreads/$(billData.directId))
              && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(billData.directId)).data.memberIds)
          );
      }

      // Allow read if user is a member (group or direct)
      allow read: if request.auth != null && (isGroupMember() || isDirectMember());

      // Allow create if:
      // 1. User is authenticated
      // 2. User is a member of the container (group or direct)
      // 3. containerType matches and corresponding ID is set
      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['containerType', 'createdBy', 'currency', 'ocrStatus', 'createdAt', 'updatedAt'])
        && (
          (request.resource.data.containerType == 'group'
            && request.resource.data.groupId != null
            && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid)))
          || (request.resource.data.containerType == 'direct'
            && request.resource.data.directId != null
            && exists(/databases/$(database)/documents/directThreads/$(request.resource.data.directId))
            && request.auth.uid in get(/databases/$(database)/documents/directThreads/$(request.resource.data.directId)).data.memberIds)
        )
        && request.resource.data.createdBy == request.auth.uid;

      // Allow update if user is a member (for updating imageUrl, ocrStatus, etc.)
      allow update: if request.auth != null && (isGroupMember() || isDirectMember());

      // Deny delete (bill uploads cannot be deleted)
      allow delete: if false;

      // Items subcollection rules
      match /items/{itemId} {
        // Allow read if user can access the parent bill upload
        allow read: if canAccessBillUpload();

        // Allow create/update if user can access the parent bill upload
        allow create, update: if canAccessBillUpload();

        // Allow delete if user can access the parent bill upload (for editing items before expense creation)
        allow delete: if canAccessBillUpload();

        // Assignments subcollection rules
        match /assignments/{userId} {
          // Allow read if user can access the parent bill upload
          allow read: if canAccessBillUpload();

          // Allow create/update if user can access the parent bill upload
          allow create, update: if canAccessBillUpload();

          // Allow delete if user can access the parent bill upload
          allow delete: if canAccessBillUpload();
        }
      }
    }
    
    // Default deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
